{"ast":null,"code":"import _Object$defineProperty from \"@babel/runtime-corejs2/core-js/object/define-property\";\nimport _Object$defineProperties from \"@babel/runtime-corejs2/core-js/object/define-properties\";\nimport _Object$getOwnPropertyDescriptors from \"@babel/runtime-corejs2/core-js/object/get-own-property-descriptors\";\nimport _Object$getOwnPropertyDescriptor from \"@babel/runtime-corejs2/core-js/object/get-own-property-descriptor\";\nimport _Object$getOwnPropertySymbols from \"@babel/runtime-corejs2/core-js/object/get-own-property-symbols\";\nimport _Object$keys from \"@babel/runtime-corejs2/core-js/object/keys\";\nimport _defineProperty from \"@babel/runtime-corejs2/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (_Object$getOwnPropertyDescriptors) { _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport React from 'react';\nimport debounceFn from 'debounce';\n\nclass ScrollManager extends React.Component {\n  constructor(props) {\n    super(props);\n\n    _defineProperty(this, \"debouncedScrollSync\", void 0);\n\n    _defineProperty(this, \"debouncedScrollSyncPending\", void 0);\n\n    _defineProperty(this, \"debouncedScroll\", void 0);\n\n    _defineProperty(this, \"scrollSyncData\", void 0);\n\n    _defineProperty(this, \"scrollSyncPending\", void 0);\n\n    this.scrollSyncData = {\n      x: 0,\n      y: 0,\n      attemptsRemaining: props.scrollSyncAttemptLimit\n    };\n\n    const scrollCapture = () => {\n      requestAnimationFrame(() => {\n        const {\n          pageXOffset,\n          pageYOffset\n        } = window;\n        const {\n          pathname\n        } = window.location; // use browser history instead of router history\n        // to avoid infinite history.replace loop\n\n        const historyState = window.history.state || {};\n        const {\n          state = {}\n        } = historyState;\n\n        if (!state.scroll || state.scroll.x !== pageXOffset || state.scroll.y !== pageYOffset) {\n          window.history.replaceState(_objectSpread({}, historyState, {\n            state: _objectSpread({}, state, {\n              scroll: {\n                x: pageXOffset,\n                y: pageYOffset\n              }\n            })\n          }), // @ts-ignore\n          null, pathname);\n        }\n      });\n    };\n\n    const _scrollSync = () => {\n      requestAnimationFrame(() => {\n        const {\n          x,\n          y,\n          attemptsRemaining\n        } = this.scrollSyncData;\n\n        if (attemptsRemaining < 1) {\n          return;\n        }\n\n        const {\n          pageXOffset,\n          pageYOffset\n        } = window;\n\n        if (y < window.document.body.scrollHeight && (x !== pageXOffset || y !== pageYOffset)) {\n          window.scrollTo(x, y);\n          this.scrollSyncData.attemptsRemaining = attemptsRemaining - 1;\n\n          _scrollSync();\n        }\n      });\n    };\n\n    const scrollSync = (x = 0, y = 0) => {\n      this.scrollSyncData = {\n        x,\n        y,\n        attemptsRemaining: this.props.scrollSyncAttemptLimit\n      };\n\n      _scrollSync();\n    };\n\n    this.debouncedScroll = debounceFn(scrollCapture, props.scrollCaptureDebounce);\n    this.debouncedScrollSync = debounceFn(scrollSync, props.scrollSyncDebounce);\n    const {\n      location,\n      onLocationChange\n    } = this.props;\n\n    if (onLocationChange) {\n      onLocationChange(location);\n    }\n  }\n\n  componentDidMount() {\n    this.onPop();\n    window.addEventListener('scroll', this.debouncedScroll, {\n      passive: true\n    });\n  }\n\n  componentWillUnmount() {\n    this.scrollSyncPending = false;\n    window.removeEventListener('scroll', this.debouncedScroll, {\n      // @ts-ignore\n      passive: true\n    });\n  }\n\n  onPush() {\n    this.debouncedScrollSync(0, 0);\n  }\n\n  onPop() {\n    this.debouncedScrollSync(0, 0);\n  }\n\n  render() {\n    return this.props.children;\n  }\n\n}\n\n_defineProperty(ScrollManager, \"defaultProps\", {\n  scrollCaptureDebounce: 50,\n  scrollSyncDebounce: 100,\n  scrollSyncAttemptLimit: 5\n});\n\nexport default ScrollManager;","map":{"version":3,"sources":["/home/vscode/code/next-boiler/components/scrollManager/index.tsx"],"names":["React","debounceFn","ScrollManager","Component","constructor","props","scrollSyncData","x","y","attemptsRemaining","scrollSyncAttemptLimit","scrollCapture","requestAnimationFrame","pageXOffset","pageYOffset","window","pathname","location","historyState","history","state","scroll","replaceState","_scrollSync","document","body","scrollHeight","scrollTo","scrollSync","debouncedScroll","scrollCaptureDebounce","debouncedScrollSync","scrollSyncDebounce","onLocationChange","componentDidMount","onPop","addEventListener","passive","componentWillUnmount","scrollSyncPending","removeEventListener","onPush","render","children"],"mappings":"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","sourcesContent":["import React from 'react';\nimport debounceFn from 'debounce';\n\ninterface Props {\n  scrollCaptureDebounce: number;\n  scrollSyncDebounce: number;\n  scrollSyncAttemptLimit: number;\n  children?: JSX.Element;\n  history?: any;\n  location?: any;\n  onLocationChange?: any;\n}\n\nclass ScrollManager extends React.Component<Props> {\n  public debouncedScrollSync: any;\n  public debouncedScrollSyncPending: any;\n  public debouncedScroll: any;\n  public scrollSyncData: any;\n  public scrollSyncPending: any;\n  public static defaultProps = {\n    scrollCaptureDebounce: 50,\n    scrollSyncDebounce: 100,\n    scrollSyncAttemptLimit: 5,\n  };\n\n  constructor(props: Props) {\n    super(props);\n\n    this.scrollSyncData = {\n      x: 0,\n      y: 0,\n      attemptsRemaining: props.scrollSyncAttemptLimit,\n    };\n\n    const scrollCapture = () => {\n      requestAnimationFrame(() => {\n        const { pageXOffset, pageYOffset } = window;\n        const { pathname } = window.location;\n\n        // use browser history instead of router history\n        // to avoid infinite history.replace loop\n        const historyState = window.history.state || {};\n        const { state = {} } = historyState;\n        if (!state.scroll || state.scroll.x !== pageXOffset || state.scroll.y !== pageYOffset) {\n          window.history.replaceState(\n            {\n              ...historyState,\n              state: { ...state, scroll: { x: pageXOffset, y: pageYOffset } },\n            },\n            // @ts-ignore\n            null,\n            pathname\n          );\n        }\n      });\n    };\n\n    const _scrollSync = () => {\n      requestAnimationFrame(() => {\n        const { x, y, attemptsRemaining } = this.scrollSyncData;\n\n        if (attemptsRemaining < 1) {\n          return;\n        }\n\n        const { pageXOffset, pageYOffset } = window;\n        if (y < window.document.body.scrollHeight && (x !== pageXOffset || y !== pageYOffset)) {\n          window.scrollTo(x, y);\n          this.scrollSyncData.attemptsRemaining = attemptsRemaining - 1;\n          _scrollSync();\n        }\n      });\n    };\n\n    const scrollSync = (x = 0, y = 0) => {\n      this.scrollSyncData = {\n        x,\n        y,\n        attemptsRemaining: this.props.scrollSyncAttemptLimit,\n      };\n      _scrollSync();\n    };\n\n    this.debouncedScroll = debounceFn(scrollCapture, props.scrollCaptureDebounce);\n    this.debouncedScrollSync = debounceFn(scrollSync, props.scrollSyncDebounce);\n\n    const { location, onLocationChange } = this.props;\n    if (onLocationChange) {\n      onLocationChange(location);\n    }\n  }\n\n  public componentDidMount() {\n    this.onPop();\n    window.addEventListener('scroll', this.debouncedScroll, { passive: true });\n  }\n\n  public componentWillUnmount() {\n    this.scrollSyncPending = false;\n    window.removeEventListener('scroll', this.debouncedScroll, {\n      // @ts-ignore\n      passive: true,\n    });\n  }\n\n  public onPush() {\n    this.debouncedScrollSync(0, 0);\n  }\n\n  public onPop() {\n    this.debouncedScrollSync(0, 0);\n  }\n\n  public render() {\n    return this.props.children;\n  }\n}\n\nexport default ScrollManager;\n"]},"metadata":{},"sourceType":"module"}